import{_ as l,W as r,X as s,Y as e,Z as n,$ as o,a2 as t,C as i}from"./framework-7d1f27fd.js";const c={},p=e("h1",{id:"csrf",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#csrf","aria-hidden":"true"},"#"),n(" CSRF")],-1),d=e("p",null,"跨站请求伪造(Cross-site request forgery,简称 CSRF)， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法",-1),h=e("h3",{id:"什么是csrf",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#什么是csrf","aria-hidden":"true"},"#"),n(" 什么是CSRF")],-1),u=e("p",null,"CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。",-1),k=e("p",null,"一个典型的CSRF攻击有着如下的流程：",-1),_={href:"http://xn--a-f38al5vkzdt61bv7l.com",target:"_blank",rel:"noopener noreferrer"},f={href:"http://xn--b-nv6ao4io8bp6po6e00mu47cda4311avpa330h.com",target:"_blank",rel:"noopener noreferrer"},m={href:"http://b.com",target:"_blank",rel:"noopener noreferrer"},C={href:"http://a.com",target:"_blank",rel:"noopener noreferrer"},b={href:"http://a.com/act=xx%E3%80%82%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E9%BB%98%E8%AE%A4%E6%90%BA%E5%B8%A6a.com%E7%9A%84Cookie%E3%80%82",target:"_blank",rel:"noopener noreferrer"},S=e("li",null,"a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。",-1),T=e("li",null,"a.com以受害者的名义执行了act=xx。",-1),F=e("li",null,"攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作。",-1),R=e("h4",{id:"csrf-示例",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#csrf-示例","aria-hidden":"true"},"#"),n(" CSRF 示例")],-1),g=e("ul",null,[e("li",null,"在私有域构造页面P")],-1),x={href:"https://blog.maplemark.cn/csrf.html",target:"_blank",rel:"noopener noreferrer"},v=t(`<p>其内容为</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token comment">&lt;!--仅用于演示，假设该点赞为 GET--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>https://segmentfault.com/api/article/1190000019050946/like?_=0faa0315ff95872d8b0f8da02e343ac7<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>诱使目标用户访问页面P</li></ul><p>如果你已经访问过 SF 网站，并且已经登录。可以看到在访问页面P之后，已经对 SF 文章进行点赞了</p><h2 id="防护策略" tabindex="-1"><a class="header-anchor" href="#防护策略" aria-hidden="true">#</a> 防护策略</h2><p>CSRF的两个特点：</p><ul><li>CSRF（通常）发生在第三方域名。</li><li>CSRF攻击者不能获取到Cookie等信息，只是使用。</li></ul><p>针对这两点，我们可以专门制定防护策略，如下：</p><ul><li>阻止不明外域的访问 <ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li>提交时要求附加本域才能获取的信息 <ul><li>CSRF Token</li><li>双重Cookie验证</li></ul></li></ul><h3 id="同源检测" tabindex="-1"><a class="header-anchor" href="#同源检测" aria-hidden="true">#</a> 同源检测</h3><p>既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。</p><p>那么问题来了，我们如何判断请求是否来自外域呢？</p><p>在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header 这两个Header在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。 服务器可以通过解析这两个Header中的域名，确定请求的来源域。</li></ul><div class="hint-container tip"><p class="hint-container-title">提示</p><p>另外，前面说过，CSRF大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p><p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的CSRF攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p></div><h3 id="csrf-token" tabindex="-1"><a class="header-anchor" href="#csrf-token" aria-hidden="true">#</a> CSRF Token</h3><p>前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。</p><p>而CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击。</p><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理" aria-hidden="true">#</a> 原理</h4><p>CSRF Token的防护策略分为三个步骤：</p><ol><li>将CSRF Token输出到页面中</li></ol><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><ol start="2"><li>页面提交的请求携带这个Token</li></ol>`,23),E={href:"http://url?csrftoken=tokenvalue%E3%80%82",target:"_blank",rel:"noopener noreferrer"},B=e("br",null,null,-1),A=e("input",{type:"”hidden”",name:"”csrftoken”",value:"”tokenvalue”/"},null,-1),H=e("br",null,null,-1),q=t('<ol start="3"><li>服务器验证Token是否正确</li></ol><p>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。</p><p>这种方法要比之前检查Referer或者Origin要安全一些，Token可以在产生并放于Session之中，然后在每次请求时把Token从Session中拿出，与请求中的Token进行比对，但这种方法的比较麻烦的在于如何把Token以参数的形式加入请求。</p><h4 id="csrf-防御" tabindex="-1"><a class="header-anchor" href="#csrf-防御" aria-hidden="true">#</a> CSRF 防御</h4><ul><li><p>增加验证码(简单有效)</p></li><li><p>检查请求来源是否合法</p></li><li><p>增加随机 token</p></li></ul>',5);function O(P,L){const a=i("ExternalLinkIcon");return r(),s("div",null,[p,d,h,u,k,e("ul",null,[e("li",null,[e("a",_,[n("受害者登录a.com"),o(a)]),n("，并保留了登录凭证（Cookie）。")]),e("li",null,[e("a",f,[n("攻击者引诱受害者访问了b.com"),o(a)]),n("。")]),e("li",null,[e("a",m,[n("b.com"),o(a)]),n(" 向 "),e("a",C,[n("a.com"),o(a)]),n(" 发送了一个请求："),e("a",b,[n("a.com/act=xx。浏览器会默认携带a.com的Cookie。"),o(a)])]),S,T,F]),R,g,e("blockquote",null,[e("p",null,[e("a",x,[n("https://blog.maplemark.cn/csrf.html"),o(a)])])]),v,e("p",null,[n("对于GET请求，Token将附在请求地址之后，这样URL 就变成 "),e("a",E,[n("http://url?csrftoken=tokenvalue。"),o(a)]),n(" 而对于 POST 请求来说，要在 form 的最后加上："),B,A,H,n(" 这样，就把Token以参数的形式加入请求了。")]),q])}const V=l(c,[["render",O],["__file","CSRF.html.vue"]]);export{V as default};
