const o=JSON.parse('{"key":"v-1c684776","path":"/interview/PHP/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20composer%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86.html","title":"深入解析 composer 的自动加载原理","lang":"zh-CN","frontmatter":{"description":"深入解析 composer 的自动加载原理 原始期 在 PHP 开发过程中，如果希望从外部引入一个 Class ，通常会使用 include 和 require 方法，去把定义这个 Class 的文件包含进来。 进化 从 PHP5 开始，当我们在使用一个类时，如果发现这个类没有加载，就会自动运行 __autoload() 函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。 __autoload() 函数存在的问题 如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的， 其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须在 __autoload() 函数中将所有的映射规则全部实现，这样的话 __autoload() 函数有可能会非常复杂，甚至无法实现。最后可能会导致 __autoload() 函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在 __autoload() 是全局函数只能定义一次 ，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个 __autoload 调用堆栈 ，不同的映射关系写到不同的 __autoload 函数中去，然后统一注册统一管理，这个就是 PHP5 引入的 SPL Autoload 。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/article/docs/interview/PHP/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90%20composer%20%E7%9A%84%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"深入解析 composer 的自动加载原理"}],["meta",{"property":"og:description","content":"深入解析 composer 的自动加载原理 原始期 在 PHP 开发过程中，如果希望从外部引入一个 Class ，通常会使用 include 和 require 方法，去把定义这个 Class 的文件包含进来。 进化 从 PHP5 开始，当我们在使用一个类时，如果发现这个类没有加载，就会自动运行 __autoload() 函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。 __autoload() 函数存在的问题 如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的， 其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须在 __autoload() 函数中将所有的映射规则全部实现，这样的话 __autoload() 函数有可能会非常复杂，甚至无法实现。最后可能会导致 __autoload() 函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在 __autoload() 是全局函数只能定义一次 ，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个 __autoload 调用堆栈 ，不同的映射关系写到不同的 __autoload 函数中去，然后统一注册统一管理，这个就是 PHP5 引入的 SPL Autoload 。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"深入解析 composer 的自动加载原理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":3,"title":"原始期","slug":"原始期","link":"#原始期","children":[]},{"level":3,"title":"进化","slug":"进化","link":"#进化","children":[]},{"level":3,"title":"现代","slug":"现代","link":"#现代","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":2.02,"words":607},"filePathRelative":"interview/PHP/深入解析 composer 的自动加载原理.md","excerpt":"<h1> 深入解析 composer 的自动加载原理</h1>\\n<h3> 原始期</h3>\\n<p>在 PHP 开发过程中，如果希望从外部引入一个 Class ，通常会使用 include 和 require 方法，去把定义这个 Class 的文件包含进来。</p>\\n<h3> 进化</h3>\\n<p>从 PHP5 开始，当我们在使用一个类时，如果发现这个类没有加载，就会自动运行 __autoload() 函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。</p>\\n<h4> __autoload() 函数存在的问题</h4>\\n<ul>\\n<li>\\n<p>如果在一个系统的实现中，如果需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的， 其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须在 __autoload() 函数中将所有的映射规则全部实现，这样的话 __autoload() 函数有可能会非常复杂，甚至无法实现。最后可能会导致 __autoload() 函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。</p>\\n</li>\\n<li>\\n<p>那么问题出现在哪里呢？问题出现在 __autoload() 是全局函数只能定义一次 ，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个 <code>__autoload 调用堆栈</code> ，不同的映射关系写到不同的 __autoload 函数中去，然后统一注册统一管理，这个就是 PHP5 引入的 SPL Autoload 。</p>\\n</li>\\n</ul>","autoDesc":true}');export{o as data};
