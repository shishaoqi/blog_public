const e=JSON.parse('{"key":"v-2f117c46","path":"/interview/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E6%8E%92%E5%BA%8F.html","title":"排序","lang":"zh-CN","frontmatter":{"description":"排序 没有一种排序算法在任何情况下都是最优的，必须根据实际情况选择最优的算法来解决问题 知识点 算法稳定性：在一组待排序记录中，如果存在任意两个相等的记录 R 和 S，且在待排序记录中 R 在 S 前，如果在排序后 R 依然在 S 前，即它们的前后位置在排序前后不发生改变，则称为排序算法为稳定的 比较类非线性时间排序：交换类排序（快速排序、冒泡排序）、插入类排序（简单插入排序、希尔排序）、选择类排序（简单选择排序、堆排序）、归并排序（二路归并排序、多路归并排序）。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/article/docs/interview/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"排序"}],["meta",{"property":"og:description","content":"排序 没有一种排序算法在任何情况下都是最优的，必须根据实际情况选择最优的算法来解决问题 知识点 算法稳定性：在一组待排序记录中，如果存在任意两个相等的记录 R 和 S，且在待排序记录中 R 在 S 前，如果在排序后 R 依然在 S 前，即它们的前后位置在排序前后不发生改变，则称为排序算法为稳定的 比较类非线性时间排序：交换类排序（快速排序、冒泡排序）、插入类排序（简单插入排序、希尔排序）、选择类排序（简单选择排序、堆排序）、归并排序（二路归并排序、多路归并排序）。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"排序\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"选择排序","slug":"选择排序","link":"#选择排序","children":[{"level":3,"title":"简单选择排序","slug":"简单选择排序","link":"#简单选择排序","children":[]},{"level":3,"title":"堆排序","slug":"堆排序","link":"#堆排序","children":[]}]},{"level":2,"title":"插入排序","slug":"插入排序","link":"#插入排序","children":[{"level":3,"title":"简单插入排序","slug":"简单插入排序","link":"#简单插入排序","children":[]},{"level":3,"title":"希尔排序","slug":"希尔排序","link":"#希尔排序","children":[]}]},{"level":2,"title":"交换排序","slug":"交换排序","link":"#交换排序","children":[{"level":3,"title":"冒泡排序","slug":"冒泡排序","link":"#冒泡排序","children":[]},{"level":3,"title":"快速排序","slug":"快速排序","link":"#快速排序","children":[]}]},{"level":2,"title":"归并排序","slug":"归并排序","link":"#归并排序","children":[]},{"level":2,"title":"基数排序","slug":"基数排序","link":"#基数排序","children":[{"level":3,"title":"桶排序","slug":"桶排序","link":"#桶排序","children":[]},{"level":3,"title":"基数排序","slug":"基数排序-1","link":"#基数排序-1","children":[]}]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":5.63,"words":1690},"filePathRelative":"interview/数据结构与算法/07.排序.md","excerpt":"<h1> 排序</h1>\\n<p>没有一种排序算法在任何情况下都是最优的，必须根据实际情况选择最优的算法来解决问题</p>\\n<div class=\\"hint-container tip\\">\\n<p class=\\"hint-container-title\\">知识点</p>\\n<p>算法稳定性：在一组待排序记录中，如果存在任意两个相等的记录 R 和 S，且在待排序记录中 R 在 S 前，如果在排序后 R 依然在 S 前，即它们的前后位置在排序前后不发生改变，则称为排序算法为稳定的</p>\\n</div>\\n<p><strong>比较类非线性时间排序</strong>：交换类排序（快速排序、冒泡排序）、插入类排序（简单插入排序、希尔排序）、选择类排序（简单选择排序、堆排序）、归并排序（二路归并排序、多路归并排序）。</p>","autoDesc":true}');export{e as data};
