import{_ as e,W as t,X as a,a2 as d}from"./framework-7d1f27fd.js";const i={},s=d(`<h1 id="mysql-事务的隔离" tabindex="-1"><a class="header-anchor" href="#mysql-事务的隔离" aria-hidden="true">#</a> MySQL 事务的隔离</h1><h3 id="事务的概念" tabindex="-1"><a class="header-anchor" href="#事务的概念" aria-hidden="true">#</a> 事务的概念</h3><p>数据库事务，是数据库管理系统执行过程中的一个逻辑单元，由一序列操作构成(即一组操作构成)，这些操作要么全部执行,要么全部不执行</p><h3 id="为什么需要事务" tabindex="-1"><a class="header-anchor" href="#为什么需要事务" aria-hidden="true">#</a> 为什么需要事务</h3><h4 id="说法一" tabindex="-1"><a class="header-anchor" href="#说法一" aria-hidden="true">#</a> 说法一</h4><p>简单来说，事务就是要保证一组数据库操作，要么全部成功，要么全部失败，从而达到数据最终的一致性。在 MySQL 中，事务支持是在引擎层实现的。你现在知道，MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。比如 MySQL 原生的 MyISAM 引擎就不支持事务。</p><h4 id="说法二" tabindex="-1"><a class="header-anchor" href="#说法二" aria-hidden="true">#</a> 说法二</h4><ul><li>事务的提出就是为了解决并发情况下保持数据一致性的问题。</li><li>事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。</li></ul><h3 id="隔离性" tabindex="-1"><a class="header-anchor" href="#隔离性" aria-hidden="true">#</a> 隔离性</h3><p>提到事务，就要说到 ACID 四大特性：</p><ul><li><p>原子性（Atomicity）<br> 事务是一个不可分割的操作序列，要么全部执行成功，要么全部失败回滚。</p></li><li><p>一致性（Consistency）<br> 在事务开始之前和结束之后，数据库的完整性约束不应被破坏。这意味着在事务结束时，数据必须处于一致的状态，即满足所有预定义的规则和约束条件。</p></li><li><p>隔离性（Isolation）<br> 多个事务同时执行时，每个事务的操作应该与其他事务的操作相互隔离，以避免相互干扰。事务应该感觉不到其他事务正在同时执行。</p></li><li><p>持久性（Durability）<br> 一旦事务被提交，它对数据库所做的更改应该永久保存，即使发生系统故障或重启，也不应该丢失。</p></li></ul><h3 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h3><p>事务之间的隔离，隔离的越严实，相应的效率也会越低，所以在操作的过程中，需要针对当前的环境，寻找一个平衡点。标准的事务隔离包括读未提交，读已提交，可重复读以及串行化。</p><ul><li><p><strong>read uncommitted</strong><br> 读未提交: 一个事务做的操作还未提交，它做的变更就能被其他事务看到。</p></li><li><p><strong>read committed</strong><br> 读已提交: 一个事务做的操作要等到他提交了事务之后才能被其他事务看到</p></li><li><p><strong>repeatable read</strong><br> 可重复读: 一个事务在执行过程中看到的数据，总是和它在启动的时候看到的数据是一样的。当然它自己未提交的事务对其他事务来说也是不可见的。</p></li><li><p><strong>serializable</strong><br> 串行化：对于同一行数据，写会加“写”锁，读会加&quot;读&quot;锁，当出现读写冲突的时候，后一个事务必须等待前一个事务提交事务，才能进行。</p></li></ul><h2 id="隔离级别测试" tabindex="-1"><a class="header-anchor" href="#隔离级别测试" aria-hidden="true">#</a> 隔离级别测试</h2><h3 id="创建表与数据" tabindex="-1"><a class="header-anchor" href="#创建表与数据" aria-hidden="true">#</a> 创建表与数据</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE \`class_teacher\` (
  \`id\` int(11) NOT NULL AUTO_INCREMENT,
  \`class_name\` varchar(100) COLLATE utf8mb4_unicode_ci NOT NULL,
  \`teacher_id\` int(11) NOT NULL,
  PRIMARY KEY (\`id\`),
  KEY \`idx_teacher_id\` (\`teacher_id\`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

insert into class_teacher values (null,&#39;初一1班&#39;,1);
insert into class_teacher values (null,&#39;初二1班&#39;,2);
insert into class_teacher values (null,&#39;初三2班&#39;,1);

update class_teacher set class_name = &quot;初一1班&quot; where teacher_id = 1;
update class_teacher set class_name = &quot;初一5班&quot; where teacher_id = 1;

select * from class_teacher;

truncate class_teacher;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-测试-读未提交" tabindex="-1"><a class="header-anchor" href="#_1-测试-读未提交" aria-hidden="true">#</a> 1.测试：读未提交</h3><p>Read Uncommitted 这种级别，任何操作都不会加锁，数据库一般都不会用。</p><ol><li>修改隔离级别 MySQL的默认隔离级别是可重复读(repeatable read)，可以使用命令查看一下</li></ol><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>show variables like &#39;transaction_isolation&#39;;

# 执行与返回
mysql&gt; show variables like &#39;transaction_isolation&#39;;
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>改成读未提交，跑命令，然后查看是否修改成功。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># set global transaction isolation level read uncommitted; 此语句修改无效
SET session transaction isolation level read uncommitted;
# 执行返回 Query OK, 0 rows affected (0.00 sec)

# 查询确认
mysql&gt; show variables like &#39;transaction_isolation&#39;;
+-----------------------+------------------+
| Variable_name         | Value            |
+-----------------------+------------------+
| transaction_isolation | READ-UNCOMMITTED |
+-----------------------+------------------+
1 row in set (0.00 sec)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>开启事务 A/B 测试 开启两个窗口：窗口A 与窗口B，代表着 A/B 两个事务，来验证隔离级别为读未提交的情况下，其他事务是否可以查看到未提交事务的更改数据。</li></ol><p>在窗口A修改完值后并未提交事务；此时在窗口B事务B中查询已经可以看到窗口A修改的值，如下：</p><table><thead><tr><th>次序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td>begin;</td></tr><tr><td>2</td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1</td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1</td></tr><tr><td>3</td><td>update class_teacher set class_name = &quot;初一5班&quot; where teacher_id = 1;</td><td></td></tr><tr><td>4</td><td></td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一5班 | 1</td></tr><tr><td>5</td><td>commit;</td><td>commit;</td></tr></tbody></table><blockquote><p>经测试，没有下面说的情况。可以正常使用 begin/start transaction -- commit 。</p></blockquote><blockquote><p>开启事务使用了 <code>start transaction with consistent snapshot</code> 。因为在MySQL中，begin/start transaction 并不是真正开启事务，而是在执行InnoDB的第一句语句的时候，事务才真正的启动。如果你想马上开启事务，那么使用上面的语句。</p></blockquote><h3 id="_2-测试-读已提交" tabindex="-1"><a class="header-anchor" href="#_2-测试-读已提交" aria-hidden="true">#</a> 2.测试：读已提交</h3><ol><li>把隔离修改成读已提交。</li><li>把 class_name=&#39;初一5班&#39; 重新修改成 class_name=&#39;初一1班&#39;，但是修改过程中不提交事务，看另一个事务是否对修改可见。</li></ol><h4 id="修改隔离级别" tabindex="-1"><a class="header-anchor" href="#修改隔离级别" aria-hidden="true">#</a> 修改隔离级别</h4><p>注意：AB 两窗口都要执行。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SET session transaction isolation level read committed;
# 执行返回 Query OK, 0 rows affected (0.00 sec)

# 查询确认
mysql&gt; show variables like &#39;transaction_isolation&#39;;
+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
+-----------------------+----------------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="事务a把-class-name-初一5班-重新修改成-class-name-初一1班-但是修改过程中不提交事务" tabindex="-1"><a class="header-anchor" href="#事务a把-class-name-初一5班-重新修改成-class-name-初一1班-但是修改过程中不提交事务" aria-hidden="true">#</a> 事务A把 class_name=&#39;初一5班&#39; 重新修改成 class_name=&#39;初一1班&#39;，但是修改过程中不提交事务</h4><table><thead><tr><th>次序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td>begin;</td></tr><tr><td>2</td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一5班 | 1</td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一5班 | 1</td></tr><tr><td>3</td><td>update class_teacher set class_name = &quot;初一1班&quot; where teacher_id = 1;</td><td></td></tr><tr><td>4</td><td></td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一5班 | 1</td></tr><tr><td>5</td><td>commit;</td><td></td></tr><tr><td>6</td><td></td><td>select * from class_teacher;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>commit;</td></tr></tbody></table><h4 id="执行修改相同行数据-发生阻塞" tabindex="-1"><a class="header-anchor" href="#执行修改相同行数据-发生阻塞" aria-hidden="true">#</a> 执行修改相同行数据，发生阻塞</h4><p>当窗口A 执行某事务，修改一些数据，并一直不commit（释放锁）前，有其它事务执行修改了相同行数据，则会一直拿不到该行锁，wait直到超时。（测试时，可以不用开启事务命令，效果相同。看窗口B # 2）</p><p>窗口A</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>mysql&gt; begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update class_teacher set class_name = &quot;初一5班&quot; where teacher_id = 1;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>窗口B</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 1.开启事务测试
begin;
Query OK, 0 rows affected (0.00 sec)

mysql&gt; update class_teacher set class_name = &quot;初一6班&quot; where teacher_id = 1;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql&gt; commit;
Query OK, 0 rows affected (0.00 sec)

# 2.不启用事务
mysql&gt; update class_teacher set class_name = &quot;初一6班&quot; where teacher_id = 1;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了防止并发过程中的修改冲突，事务A中MySQL给teacher_id=1的数据行加锁，并一直不commit（释放锁），那么事务B也就一直拿不到该行锁，wait直到超时。 -- 注意，此处的行锁，在后面的 MVCC 中有重头戏。</p><blockquote><p>这时我们要注意到，teacher_id是有索引的，如果是没有索引的class_name呢？update class_teacher set teacher_id=3 where class_name = ‘初一1班’; 那么MySQL会给整张表的所有数据行的加行锁。这里听起来有点不可思议，但是当sql运行的过程中，MySQL并不知道哪些数据行是 class_name = ‘初一1班’的（没有索引嘛），如果一个条件无法通过索引快速过滤，存储引擎层面就会将所有记录加锁后返回，再由MySQL Server层进行过滤。</p></blockquote><blockquote><p>但在实际使用过程当中，MySQL做了一些改进，在MySQL Server过滤条件，发现不满足后，会调用unlock_row方法，把不满足条件的记录释放锁 (违背了二段锁协议的约束)。这样做，保证了最后只会持有满足条件记录上的锁，但是每条记录的加锁操作还是不能省略的。可见即使是MySQL，为了效率也是会违反规范的。（参见《高性能MySQL》中文第三版p181）</p></blockquote><blockquote><p>这种情况同样适用于MySQL的默认隔离级别RR。所以对一个数据量很大的表做批量修改的时候，如果无法使用相应的索引，MySQL Server过滤数据的的时候特别慢，就会出现虽然没有修改某些行的数据，但是它们还是被锁住了的现象。</p></blockquote><h3 id="_3-测试-可重复读" tabindex="-1"><a class="header-anchor" href="#_3-测试-可重复读" aria-hidden="true">#</a> 3.测试：可重复读</h3><h4 id="读" tabindex="-1"><a class="header-anchor" href="#读" aria-hidden="true">#</a> 读</h4><p>读就是可重读，可重读这个概念是一事务的多个实例在并发读取数据时，会看到同样的数据行，有点抽象，我们来看一下效果。</p><h4 id="_1-rc-不可重读-模式下的展现" tabindex="-1"><a class="header-anchor" href="#_1-rc-不可重读-模式下的展现" aria-hidden="true">#</a> 1. RC（不可重读）模式下的展现</h4><p>补插入两条数据</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>insert into class_teacher values (null,&#39;初三2班&#39;,1);
insert into class_teacher values (null,&#39;初二1班&#39;,2);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>次序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td>gegin;</td></tr><tr><td>2</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td><td></td></tr><tr><td>3</td><td></td><td>update class_teacher set class_name = &#39;初一8班&#39; where id = 1;<br>commit;</td></tr><tr><td>4</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一8班 | 1<br>2 | 初三2班 | 1</td><td></td></tr><tr><td>5</td><td>commit;</td><td></td></tr></tbody></table><p>事务B修改 id=1 的数据提交之后，事务A同样的查询，后一次和前一次的结果不一样，这就是不可重读（重新读取产生的结果不一样）。这就很可能带来一些问题。</p><h4 id="_2-rr模式下的展现" tabindex="-1"><a class="header-anchor" href="#_2-rr模式下的展现" aria-hidden="true">#</a> 2. RR模式下的展现</h4><p>修改隔离级别。注意：AB 两窗口都要执行。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SET session transaction isolation level repeatable read;
# 执行返回 Query OK, 0 rows affected (0.00 sec)

# 确认修改结果
mysql&gt; show variables like &#39;transaction_isolation&#39;;
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>次序</th><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td>begin;</td><td>begin;</td></tr><tr><td>2</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td><td></td><td></td></tr><tr><td>3</td><td></td><td>update class_teacher set class_name = &#39;初一8班&#39; where id = 1;<br>commit;</td><td></td></tr><tr><td>4</td><td></td><td></td><td>insert into class_teacher values (null,&#39;初三4班&#39;,1);<br>commit;</td></tr><tr><td>5</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td><td></td><td></td></tr><tr><td>6</td><td>commit;</td><td></td><td></td></tr></tbody></table><p>没有读到事务B修改的数据，和第一次sql读取的一样，是可重复读的。也没有读到事务C新添加的数据。</p><p>我们注意到，当teacher_id=1时，事务A先做了一次读取，事务B中间修改了id=1的数据，并commit之后，事务A第二次读到的数据和第一次完全相同。所以说它是可重读的。那么MySQL是怎么做到的呢？</p><h4 id="_3-mvcc-多版本并发控制-的引入" tabindex="-1"><a class="header-anchor" href="#_3-mvcc-多版本并发控制-的引入" aria-hidden="true">#</a> 3. MVCC（多版本并发控制）的引入</h4><ol><li>不可重复读和幻读的区别</li></ol><p>很多人容易搞混不可重复读和幻读，确实这两者有些相似。但不可重复读重点在于update和delete，而幻读的重点在于insert。</p><p>如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，这就是: 幻读，不能通过行锁来避免。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。---- Serializable隔离级别并不合适用于解决 幻读，那要怎么解决，请注意下面 MVCC 中提到的的：快照读、当前读、 Next-Key 锁</p><p>所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。</p><p>上文说的，是使用悲观锁机制来处理这两种问题，但是MySQL、ORACLE、PostgreSQL等成熟的数据库，出于性能考虑，都是使用了以乐观锁为理论基础的MVCC（多版本并发控制）来避免这两种问题。</p><ol start="2"><li>悲观锁和乐观锁</li></ol><p>悲观锁 正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p><p>乐观锁 相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p>要说明的是，MVCC的实现没有固定的规范，每个数据库都会有不同的实现方式，这里讨论的是InnoDB的MVCC。</p><ol start="3"><li>MVCC在MySQL的InnoDB中的实现 在InnoDB中，会在每行数据后添加两个额外的隐藏的字段来实现MVCC，这两个字段：一个记录这行数据何时被创建，另外一个记录这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的版本号就会递增。 在可重读 Repeatable reads 事务隔离级别下：</li></ol><ul><li>SELECT时，读取创建版本号&lt;=当前事务版本号，删除版本号为空或&gt;当前事务版本号。</li><li>INSERT时，保存当前事务版本号为行的创建版本号</li><li>DELETE时，保存当前事务版本号为行的删除版本号</li><li>UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行 通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。</li></ul><p>我们不管从数据库方面的教课书中学到，还是从网络上看到，大都是上文中事务的四种隔离级别这一模块列出的意思，RR 级别是可重复读的，但无法解决幻读，而只有在 Serializable 级别才能解决幻读。于是我就加了一个事务C来展示效果。在事务C中添加了一条teacher_id=1的数据commit，RR级别中应该会有幻读现象，事务A在查询teacher_id=1的数据时会读到事务C新加的数据。但是测试后发现，在MySQL中是不存在这种情况的，在事务C提交后，事务A还是不会读到这条数据。** 可见在MySQL的 RR 级别中，是解决了幻读的读问题的。** 参见下面的测试</p><table><thead><tr><th>次序</th><th>事务A</th><th>事务B</th><th>事务C</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td>begin;</td><td>begin;</td></tr><tr><td>2</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td><td></td><td></td></tr><tr><td>3</td><td></td><td>update class_teacher set class_name = &#39;初一8班&#39; where id = 1;<br>commit;</td><td></td></tr><tr><td>4</td><td></td><td></td><td>insert into class_teacher values (null,&#39;初三4班&#39;,1);<br>commit;</td></tr><tr><td>5</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td><td></td><td></td></tr><tr><td>6</td><td>commit;</td><td></td><td></td></tr></tbody></table><h3 id="_4-测试-串行化" tabindex="-1"><a class="header-anchor" href="#_4-测试-串行化" aria-hidden="true">#</a> 4.测试：串行化</h3><h4 id="修改隔离级别-1" tabindex="-1"><a class="header-anchor" href="#修改隔离级别-1" aria-hidden="true">#</a> 修改隔离级别</h4><p>修改隔离级别。注意：AB 两窗口都要执行。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SET session transaction isolation level serializable;
# 执行返回 Query OK, 0 rows affected (0.00 sec)

# 确认修改结果
mysql&gt; show variables like &#39;transaction_isolation&#39;;
+-----------------------+-----------------+
| Variable_name         | Value           |
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.00 sec)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h4><table><thead><tr><th>次序</th><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>1</td><td>begin;</td><td>gegin;</td></tr><tr><td>2</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td><td>select * from class_teacher where teacher_id = 1;<br>id | class_name | teacher_id<br>1 | 初一1班 | 1<br>2 | 初三2班 | 1</td></tr><tr><td>3</td><td></td><td>update class_teacher set class_name = &#39;初一8班&#39; where id = 1;<br>被锁住了，光标停止不动</td></tr><tr><td>4</td><td>commit;</td><td></td></tr><tr><td>5</td><td></td><td>成功执行</td></tr></tbody></table>`,81),r=[s];function n(l,c){return t(),a("div",null,r)}const o=e(i,[["render",n],["__file","事务.html.vue"]]);export{o as default};
