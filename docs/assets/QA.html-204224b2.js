import{_ as e,W as d,X as a,a2 as t}from"./framework-7d1f27fd.js";const n={},s=t(`<h1 id="问题与简答" tabindex="-1"><a class="header-anchor" href="#问题与简答" aria-hidden="true">#</a> 问题与简答</h1><h2 id="redis-篇" tabindex="-1"><a class="header-anchor" href="#redis-篇" aria-hidden="true">#</a> Redis 篇</h2><h3 id="redis-介绍" tabindex="-1"><a class="header-anchor" href="#redis-介绍" aria-hidden="true">#</a> Redis 介绍</h3><p>Redis 是一个高性能的 key-value 数据库。每秒可执行操作高达 10万+ QPS</p><h3 id="redis-特点" tabindex="-1"><a class="header-anchor" href="#redis-特点" aria-hidden="true">#</a> Redis 特点</h3><ul><li>支持数据持久化，可将内存中的数据保存在磁盘，重启时再次加载</li><li>支持 KV 类型数据，也支持其他丰富的数据结构存储</li><li>支持数据备份，即 master-slave 模式的数据备份</li></ul><h3 id="redis-支持哪些数据结构" tabindex="-1"><a class="header-anchor" href="#redis-支持哪些数据结构" aria-hidden="true">#</a> Redis 支持哪些数据结构</h3><ul><li><p>STRING：字符串、整数或浮点数</p></li><li><p>LIST：列表，可存储多个相同的字符串</p></li><li><p>SET：集合，存储不同元素，无序排列</p></li><li><p>HASH：散列表，存储键值对之间的映射，无序排列</p></li><li><p>ZSET：有序集合，存储键值对，有序排列</p></li></ul><h3 id="redis-与-memcache-区别" tabindex="-1"><a class="header-anchor" href="#redis-与-memcache-区别" aria-hidden="true">#</a> Redis 与 Memcache 区别</h3><table><thead><tr><th>对比项</th><th>Redis</th><th>Memcache</th></tr></thead><tbody><tr><td>数据结构</td><td>丰富数据类型</td><td>只支持简单 KV 数据类型</td></tr><tr><td>数据一致性</td><td>事务</td><td>cas</td></tr><tr><td>持久性</td><td>快照/AOF</td><td>不支持</td></tr><tr><td>网络IO</td><td>单线程 IO 复用</td><td>多线程、非阻塞 IO 复用</td></tr><tr><td>内存管理机制</td><td>现场申请内存</td><td>预分配内存</td></tr></tbody></table><h3 id="发布订阅" tabindex="-1"><a class="header-anchor" href="#发布订阅" aria-hidden="true">#</a> 发布订阅</h3><p>发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息</p><h3 id="持久化策略" tabindex="-1"><a class="header-anchor" href="#持久化策略" aria-hidden="true">#</a> 持久化策略</h3><h4 id="快照持久化-rdb" tabindex="-1"><a class="header-anchor" href="#快照持久化-rdb" aria-hidden="true">#</a> 快照持久化 RDB</h4><p>将某一时刻的所有数据写入硬盘。使用<code>BGSAVE</code>命令，随着内存使用量的增加，执行 BGSAVE 可能会导致系统长时间地停顿</p><h4 id="aof-持久化" tabindex="-1"><a class="header-anchor" href="#aof-持久化" aria-hidden="true">#</a> AOF 持久化</h4><p>只追加文件，在执行写命令时，将被执行的写命令复制到硬盘里面。使用 AOF 策略需要对硬盘进行大量写入，Redis 处理速度会受到硬盘性能的限制</p><h3 id="redis-事务" tabindex="-1"><a class="header-anchor" href="#redis-事务" aria-hidden="true">#</a> Redis 事务</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis<span class="token operator">&gt;</span> MULTI  <span class="token comment">#标记事务开始</span>
OK
redis<span class="token operator">&gt;</span> INCR user_id  <span class="token comment">#多条命令按顺序入队</span>
QUEUED
redis<span class="token operator">&gt;</span> INCR user_id
QUEUED
redis<span class="token operator">&gt;</span> INCR user_id
QUEUED
redis<span class="token operator">&gt;</span> PING
QUEUED
redis<span class="token operator">&gt;</span> EXEC  <span class="token comment">#执行</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">4</span><span class="token punctuation">)</span> PONG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行</p></blockquote><blockquote><p>使用 DISCARD 可以取消事务，放弃执行事务块内的所有命令</p></blockquote><h3 id="如何实现分布式锁" tabindex="-1"><a class="header-anchor" href="#如何实现分布式锁" aria-hidden="true">#</a> 如何实现分布式锁</h3><h4 id="方式一" tabindex="-1"><a class="header-anchor" href="#方式一" aria-hidden="true">#</a> 方式一</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>tryLock() {
    SETNX Key 1 Seconds
}
release() {
    DELETE Key
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缺陷：C<sub>1</sub> 执行时间过长未主动释放锁，C<sub>2</sub> 在 C<sub>1</sub> 的锁超时后获取到锁，C<sub>1</sub> 和 C<sub>2</sub> 都同时在执行，可能造成数据不一致等未知情况。如果 C<sub>1</sub> 先执行完毕，则会释放 C<sub>2</sub> 的锁，此时可能导致另外一个 C<sub>3</sub> 获取到锁</p><h4 id="方式二" tabindex="-1"><a class="header-anchor" href="#方式二" aria-hidden="true">#</a> 方式二</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>tryLock() {
    SETNX Key UnixTimestamp Seconds
}
release() {
    EVAL (
        //LuaScript
        if redis.call(&quot;get&quot;, KEYS[1] == ARGV[1]) then
            return redis.call(&quot;del&quot;, KEYS[1])
        else
            return 0
        end
    )
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缺陷：极高并发场景下(如抢红包场景)，可能存在 UnixTimestamp 重复问题。分布式环境下物理时钟一致性，也无法保证，也可能存在 UnixTimestamp 重复问题</p><h4 id="方式三" tabindex="-1"><a class="header-anchor" href="#方式三" aria-hidden="true">#</a> 方式三</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>tryLock() {
    SET Key UniqId Seconds
}
release() {
    EVAL (
        //LuaScript
        if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then
            return redis.call(&quot;del&quot;, KEYS[1])
        else
            return 0
        end
    )
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>执行 <code>SET key value NX</code> 的效果等同于执行 <code>SETNX key value</code></p></blockquote><p>目前最优的分布式锁方案，但是如果在集群下依然存在问题。由于 Redis 集群数据同步为异步，假设在 Master 节点获取到锁后未完成数据同步情况下 Master 节点 crash，在新的 Master 节点依然可以获取锁，所以多个 Client 同时获取到了锁</p><h3 id="redis-过期策略及内存淘汰机制" tabindex="-1"><a class="header-anchor" href="#redis-过期策略及内存淘汰机制" aria-hidden="true">#</a> Redis 过期策略及内存淘汰机制</h3><h4 id="过期策略" tabindex="-1"><a class="header-anchor" href="#过期策略" aria-hidden="true">#</a> 过期策略</h4><p>Redis 的过期策略就是指当 Redis 中缓存的 Key 过期了，Redis 如何处理</p><ul><li><p>定时过期：每个设置过期时间的 Key 创建定时器，到过期时间立即清除。内存友好，CPU 不友好</p></li><li><p>惰性过期：访问 Key 时判断是否过期，过期则清除。CPU 友好，内存不友好</p></li><li><p>定期过期：隔一定时间，expires 字典中扫描一定数量的 Key，清除其中已过期的 Key。内存和 CPU 资源达到最优的平衡效果</p></li></ul><h4 id="内存淘汰机制" tabindex="-1"><a class="header-anchor" href="#内存淘汰机制" aria-hidden="true">#</a> 内存淘汰机制</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token comment"># redis-cli config get maxmemory-policy</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;maxmemory-policy&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;noeviction&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>noeviction：新写入操作会报错</li><li>allkeys-lru：移除最近最少使用的 key</li><li>allkeys-random：随机移除某些 key</li><li>volatile-lru：在设置了过期时间的键中，移除最近最少使用的 key</li><li>volatile-random：在设置了过期时间的键中，随机移除某些 key</li><li>volatile-ttl：在设置了过期时间的键中，有更早过期时间的 key 优先移除</li></ul><h3 id="为什么-redis-是单线程的" tabindex="-1"><a class="header-anchor" href="#为什么-redis-是单线程的" aria-hidden="true">#</a> 为什么 Redis 是单线程的</h3><p>Redis 是基于内存的操作，CPU 不是 Redis 的瓶颈，Redis 瓶颈最有可能是内存或网络。而且单线程容易实现，避免了不必要的上下文切换和竞争条件，不存在多线程切换消耗 CPU</p><h3 id="如何利用-cpu-多核心" tabindex="-1"><a class="header-anchor" href="#如何利用-cpu-多核心" aria-hidden="true">#</a> 如何利用 CPU 多核心</h3><p>在单机单实例下，如果操作都是 O(N)、O(log(N)) 复杂度，对 CPU 消耗不会太高。为了最大利用 CPU，单机可以部署多个实例</p><h3 id="集合命令的实现方法" tabindex="-1"><a class="header-anchor" href="#集合命令的实现方法" aria-hidden="true">#</a> 集合命令的实现方法</h3><table><thead><tr><th>命令</th><th>intset 编码的实现方法</th><th>hashtable 编码的实现方法</th></tr></thead><tbody><tr><td>SADD</td><td>调用 intsetAdd 函数，将所有新元素添加到整数集合里面</td><td>调用 dictAdd，以新元素为键，NULL 为值，将键值对添加到字典里面</td></tr><tr><td>SCARD</td><td>调用 intsetLen 函数，返回整数集合所包含的元素数量，这个数量就是集合对象所包含的元素数量</td><td>调用 dictSize 函数，返回字典所包含的键值对数量，这个数量就是集合对象所包含的元素数量</td></tr><tr><td>SISMEMBER</td><td>调用 intsetFind 函数，在整数集合中查找给定的元素，如果找到了元素存在于集合，没找到则说明元素不存在集合</td><td>调用 dictFind 函数，在字典的键中查找给定的元素，如果找到了说明元素存在于集合，没找到则说明元素不存在于集合</td></tr><tr><td>SMEMBERS</td><td>遍历整个整数集合，调用 inisetGet 函数返回集合元素</td><td>遍历整个字典，使用 dictGetKey 函数返回字典的键作为集合元素</td></tr><tr><td>SRANDMEMBER</td><td>调用 intsetRandom 函数，从整数集合中随机返回一个元素</td><td>调用 dictGetRandomKey 函数，从字典中随机返回一个字典键</td></tr><tr><td>SPOP</td><td>调用 intsetRandom 函数，从整数集合中随机取出一个元素，再将这个随机元素返回给客户端之后，调用 intsetRemove 函数，将随机元素从整数集合中删除掉</td><td>调用 dictGetRandomKey 函数，从字典中随机取出一个字典键，在将这个随机字典键的值返回给客户端之后，调用 dictDelete 函数，从字典中删除随机字典键所对应的键值对</td></tr><tr><td>SREM</td><td>调用 intsetRemove 函数，从整数集合中删除所有给定的元素</td><td>调用 dictDelete 函数，从字典中删除所有键为给定元素的键值对</td></tr></tbody></table><h3 id="有序集合命令的实现方法" tabindex="-1"><a class="header-anchor" href="#有序集合命令的实现方法" aria-hidden="true">#</a> 有序集合命令的实现方法</h3><table><thead><tr><th>命令</th><th>ziplist 编码的实现方法</th><th>zset 编码的实现方法</th></tr></thead><tbody><tr><td>ZADD</td><td>调用 ziplistInsert 函数，将成员和分值作为两个节点分别插入到压缩列表</td><td>先调用 zslInsert 函数，将新元素添加到跳跃表，然后调用 dictAdd 函数，将新元素关联到字典</td></tr><tr><td>ZCARD</td><td>调用 ziplistLen 函数，获得压缩列表包含节点的数量，将这个数量除以2得出集合元素的数量</td><td>访问跳跃表数据结构的 length 属性，直接访问集合元素的数量</td></tr><tr><td>ZCOUND</td><td>遍历压缩列表，统计分值在给定范围内的节点的数量</td><td>遍历跳跃表，统计分值在给定范围内的节点的数量</td></tr><tr><td>ZRANGE</td><td>从表头向表尾遍历压缩列表，返回给定索引范围内的所有元素</td><td>从表头向表尾遍历跳跃表，返回给定索引范围内的所有元素</td></tr><tr><td>ZREVRANGE</td><td>表尾向表头遍历压缩列表，返回给定索引范围内的所有元素</td><td>从表尾向表头遍历跳跃表，返回给定索引范围的所有元素</td></tr><tr><td>ZRANK</td><td>从表头向表尾遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td><td>从表头向表尾遍历跳跃表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td></tr><tr><td>ZREVRANK</td><td>从表尾向表头遍历压缩列表，查找给定的成员，沿途记录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td><td>从表尾向表头遍历跳跃表，查找给定的成员，沿途纪录经过节点的数量，当找到给定成员之后，沿途节点的数量就是该成员所对应元素的排名</td></tr><tr><td>ZREM</td><td>遍历压缩列表，删除所有包含给定成员的节点，以及被删除成员节点旁边的分值节点</td><td>遍历跳跃表，删除所有包含了给定成员的跳跃表节点。并在字典中解除被删除元素的成员和分值关联</td></tr><tr><td>ZSCORE</td><td>遍历压缩列表，查找包含了给定成员的节点，然后取出成员节点旁边的分值节点保存的元素分值</td><td>直接从字典中取出给定成员的分值</td></tr></tbody></table><h3 id="redis-跳跃表" tabindex="-1"><a class="header-anchor" href="#redis-跳跃表" aria-hidden="true">#</a> redis 跳跃表</h3><p>跳跃表(skiplist)是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p><p>在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><h3 id="redis-conf-配置" tabindex="-1"><a class="header-anchor" href="#redis-conf-配置" aria-hidden="true">#</a> redis.conf 配置</h3><h3 id="慢查询" tabindex="-1"><a class="header-anchor" href="#慢查询" aria-hidden="true">#</a> 慢查询</h3>`,53),i=[s];function r(l,c){return d(),a("div",null,i)}const h=e(n,[["render",r],["__file","QA.html.vue"]]);export{h as default};
