import{_ as e,W as t,X as a,a2 as i}from"./framework-7d1f27fd.js";const n="/article/docs/assets/TCP_TIME_WAIT-fab87378.png",r={},s=i('<h1 id="tcp-time-wait" tabindex="-1"><a class="header-anchor" href="#tcp-time-wait" aria-hidden="true">#</a> TCP TIME_WAIT</h1><p>TCP 协议需要 TIME_WAIT 状态的原因和客户端需要等待两个 MSL 不能直接进入 CLOSED 状态的原因是一样的：</p><ol><li><p>防止延迟的数据段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 连接收到；</p></li><li><p>保证 TCP 连接的正常关闭，即等待被动关闭连接的一方收到 最终的(FIN 对应的) ACK 消息；</p></li></ol><p>上述两个原因都相对比较简单，我们来展开介绍这两个原因背后可能存在的一些问题。</p><h3 id="阻止延迟数据段" tabindex="-1"><a class="header-anchor" href="#阻止延迟数据段" aria-hidden="true">#</a> 阻止延迟数据段</h3><p>为了保证新 TCP 连接的数据段不会与还在网络中传输的历史连接的数据段重复，TCP 连接在分配新的序列号之前需要至少静默数据段在网络中能够存活的最长时间，即 MSL。</p><p>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.</p><h3 id="保证连接关闭" tabindex="-1"><a class="header-anchor" href="#保证连接关闭" aria-hidden="true">#</a> 保证连接关闭</h3><p>从 RFC 793 对 TIME_WAIT 状态的定义中，我们可以发现该状态的另一个重要作用，等待足够长的时间以确定远程的 TCP 连接接收到了其发出的终止连接消息 FIN 对应的 ACK：</p><p>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</p><p>在默认情况下，如果客户端等待足够长的时间就会遇到以下两种情况：</p><p>服务端正常收到了 ACK 消息并关闭当前 TCP 连接；</p><ol><li>服务端没有收到 ACK 消息，重新发送 FIN 关闭连接并等待新的 ACK 消息；</li><li>只要客户端等待 2 MSL 的时间，客户端和服务端之间的连接就会正常关闭，新创建的 TCP 连接收到影响的概率也微乎其微，保证了数据传输的可靠性。</li></ol><figure><img src="'+n+'" alt="tcp_time_wait" tabindex="0" loading="lazy"><figcaption>tcp_time_wait</figcaption></figure>',14),o=[s];function c(p,h){return t(),a("div",null,o)}const m=e(r,[["render",c],["__file","TCP TIME_WAIT.html.vue"]]);export{m as default};
