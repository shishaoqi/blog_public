import{_ as t,W as p,X as i,Y as a,Z as n,$ as l,a2 as s,C as c}from"./framework-7d1f27fd.js";const o={},r=a("h1",{id:"魔术方法",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#魔术方法","aria-hidden":"true"},"#"),n(" 魔术方法")],-1),d=a("p",null,"PHP 中把以两个下划线开头的方法称为魔术方法（Magic methods）",-1),u={href:"https://www.php.net/manual/zh/language.oop5.magic.php",target:"_blank",rel:"noopener noreferrer"},h=s(`<p>魔术方法包括：</p><ol><li><p>__construct()，类的构造函数</p></li><li><p>__destruct()，类的析构函数</p></li><li><p>__call()，在对象中调用一个不可访问方法时调用</p></li><li><p>__callStatic()，用静态方式中调用一个不可访问方法时调用</p></li><li><p>__get()，读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用</p></li><li><p>__set()，在给不可访问（protected 或 private）或不存在的属性赋值时，__set() 会被调用</p></li><li><p>__isset()，当对不可访问（protected 或 private）或不存在的属性调用 <code>isset() 或 empty()</code> 时，__isset() 会被调用</p></li><li><p>__unset()，当对不可访问（protected 或 private）或不存在的属性调用 <code>unset()</code> 时，__unset() 会被调用</p></li><li><p>__sleep()，serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作</p></li><li><p>__wakeup()，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源</p></li><li><p>__toString()，类被当成字符串时的回应方法</p></li><li><p>__invoke()，调用函数的方式调用一个对象时的回应方法</p></li><li><p>__set_state()，调用var_export()导出类时，此静态方法会被调用。</p></li><li><p>__clone()，当对象复制完成时调用</p></li><li><p>__autoload()，尝试加载未定义的类</p></li><li><p>__debugInfo()，打印所需调试信息</p></li><li><p>__serialize()</p></li><li><p>__unserialize()</p></li></ol><blockquote><p><strong>警告</strong> 除了 __construct()， __destruct() ，和 __clone() 之外的所有魔术方法都必须声明为 public， 否则会发出 E_WARNING。 在 PHP 8.0.0 之前没有为魔术方法 __sleep() 、 __wakeup() 、 __serialize() 、 __unserialize() 、 __set_state() 发出诊断信息。</p></blockquote><h3 id="construct" tabindex="-1"><a class="header-anchor" href="#construct" aria-hidden="true">#</a> __construct()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">__construct</span><span class="token punctuation">(</span><span class="token keyword type-declaration">mixed</span> <span class="token operator">...</span><span class="token variable">$values</span> <span class="token operator">=</span> <span class="token string double-quoted-string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>PHP 允许开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。</p><div class="hint-container tip"><p class="hint-container-title">注意</p><p>如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。</p></div><h3 id="destruct" tabindex="-1"><a class="header-anchor" href="#destruct" aria-hidden="true">#</a> __destruct()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>PHP 有析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</p><p>和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。</p><p>析构函数即使在使用 exit() 终止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。</p><h2 id="方法重载" tabindex="-1"><a class="header-anchor" href="#方法重载" aria-hidden="true">#</a> 方法重载</h2><h3 id="call" tabindex="-1"><a class="header-anchor" href="#call" aria-hidden="true">#</a> __call()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__call</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token keyword type-hint">array</span> <span class="token variable">$arguments</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">mixed</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,15),_=a("p",null,[n("在对象中调用一个不可访问（或不存在）的方法时，__call() 会被调用。"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n"),a("mi",null,"a"),a("mi",null,"m"),a("mi",null,"e"),a("mtext",null,"参数是要调用的方法名称。")]),a("annotation",{encoding:"application/x-tex"},"name 参数是要调用的方法名称。")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"nam"),a("span",{class:"mord mathnormal"},"e"),a("span",{class:"mord cjk_fallback"},"参数是要调用的方法名称。")])])]),n("arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。")],-1),k=s(`<h3 id="callstatic" tabindex="-1"><a class="header-anchor" href="#callstatic" aria-hidden="true">#</a> __callStatic()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token function">__callStatic</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token keyword type-hint">array</span> <span class="token variable">$arguments</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">mixed</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),v=a("p",null,[n("在静态上下文中调用一个不可访问（或不存在）的方法时，__callStatic() 会被调用。"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"n"),a("mi",null,"a"),a("mi",null,"m"),a("mi",null,"e"),a("mtext",null,"参数是要调用的方法名称。")]),a("annotation",{encoding:"application/x-tex"},"name 参数是要调用的方法名称。")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"0.6833em"}}),a("span",{class:"mord mathnormal"},"nam"),a("span",{class:"mord mathnormal"},"e"),a("span",{class:"mord cjk_fallback"},"参数是要调用的方法名称。")])])]),n("arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。")],-1),m=s(`<h2 id="属性重载" tabindex="-1"><a class="header-anchor" href="#属性重载" aria-hidden="true">#</a> 属性重载</h2><h3 id="get" tabindex="-1"><a class="header-anchor" href="#get" aria-hidden="true">#</a> __get()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__get</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">mixed</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>读取不可访问（protected 或 private）或不存在的属性的值时，__get() 会被调用</p><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> __set()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__set</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">,</span> <span class="token keyword type-hint">mixed</span> <span class="token variable">$value</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在给不可访问（protected 或 private）或不存在的属性赋值时，__set() 会被调用</p><h3 id="isset" tabindex="-1"><a class="header-anchor" href="#isset" aria-hidden="true">#</a> __isset()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__isset</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">bool</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当对不可访问（protected 或 private）或不存在的属性调用 isset() 或 empty() 时，__isset() 会被调用。</p><h3 id="unset" tabindex="-1"><a class="header-anchor" href="#unset" aria-hidden="true">#</a> __unset()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__unset</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$name</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当对不可访问（protected 或 private）或不存在的属性调用 unset() 时，__unset() 会被调用</p><h3 id="sleep" tabindex="-1"><a class="header-anchor" href="#sleep" aria-hidden="true">#</a> __sleep()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行serialize()时，先会调用这个函数。 __sleep() 方法常用于提交<code>未提交</code>的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。</p><h3 id="wakeup" tabindex="-1"><a class="header-anchor" href="#wakeup" aria-hidden="true">#</a> __wakeup()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__wakeup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行unserialize()时，先会调用这个函数。 __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</p><h3 id="tostring" tabindex="-1"><a class="header-anchor" href="#tostring" aria-hidden="true">#</a> __toString()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">string</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>__toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。-- 即：类被当成字符串时的回应方法</p><h3 id="invoke" tabindex="-1"><a class="header-anchor" href="#invoke" aria-hidden="true">#</a> __invoke()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">__invoke</span><span class="token punctuation">(</span> <span class="token operator">...</span><span class="token variable">$values</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">mixed</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。-- 即：调用函数的方式调用一个对象时的回应方法</p><h3 id="set-state" tabindex="-1"><a class="header-anchor" href="#set-state" aria-hidden="true">#</a> __set_state()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">static</span> <span class="token function">__set_state</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$properties</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">object</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当调用 var_export() 导出类时，此静态方法会被调用。</p><p>本方法的唯一参数是一个数组，其中包含按 [&#39;property&#39; =&gt; value, ...] 格式排列的类属性。</p><h3 id="clone" tabindex="-1"><a class="header-anchor" href="#clone" aria-hidden="true">#</a> __clone()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">__clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。</p><h3 id="autoload" tabindex="-1"><a class="header-anchor" href="#autoload" aria-hidden="true">#</a> __autoload()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">__autoload</span><span class="token punctuation">(</span><span class="token keyword type-hint">string</span> <span class="token variable">$class</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>尝试加载未定义的类<br> 本函数已自 PHP 7.2.0 起被废弃，并自 PHP 8.0.0 起被移除。 强烈建议不要依赖本函数。</p><h3 id="debuginfo" tabindex="-1"><a class="header-anchor" href="#debuginfo" aria-hidden="true">#</a> __debugInfo()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token function">__debugInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当通过 var_dump() 输出对象，获取应该要显示的属性的时候，该函数就会被调用。如果对象中没有定义该方法，那么将会展示所有的公有、受保护和私有的属性。</p><h3 id="serialize" tabindex="-1"><a class="header-anchor" href="#serialize" aria-hidden="true">#</a> __serialize()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__serialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">array</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>serialize() 函数会检查类中是否存在一个魔术方法 __serialize() 。如果存在，该方法将在任何序列化之前优先执行。它必须以一个代表对象序列化形式的 键/值 成对的关联数组形式来返回，如果没有返回数组，将会抛出一个 TypeError 错误。</p><div class="hint-container tip"><p class="hint-container-title">注意</p><p>如果类中同时定义了 __serialize() 和 __sleep() 两个魔术方法，则只有 __serialize() 方法会被调用。 __sleep() 方法会被忽略掉。如果对象实现了 Serializable 接口，接口的 serialize() 方法会被忽略，做为代替类中的 __serialize() 方法会被调用。</p><p>__serialize() 的预期用途是定义对象序列化友好的任意表示。 数组的元素可能对应对象的属性，但是这并不是必须的。</p><p>此特性自 PHP 7.4.0 起可用。</p></div><h3 id="unserialize" tabindex="-1"><a class="header-anchor" href="#unserialize" aria-hidden="true">#</a> __unserialize()</h3><div class="language-php line-numbers-mode" data-ext="php"><pre class="language-php"><code><span class="token keyword">public</span> <span class="token function">__unserialize</span><span class="token punctuation">(</span><span class="token keyword type-hint">array</span> <span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword return-type">void</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>相反， unserialize() 检查是否存在具有名为 __unserialize() 的魔术方法。此函数将会传递从 __serialize() 返回的恢复数组。然后它可以根据需要从该数组中恢复对象的属性。</p><div class="hint-container tip"><p class="hint-container-title">注意</p><p>如果类中同时定义了 __unserialize() 和 __wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。</p><p>此特性自 PHP 7.4.0 起可用。</p></div>`,46);function b(g,y){const e=c("ExternalLinkIcon");return p(),i("div",null,[r,d,a("blockquote",null,[a("p",null,[a("a",u,[n("官方说法"),l(e)]),n("：魔术方法是一种特殊的方法，当对对象执行某些操作时会覆盖 PHP 的默认操作。")])]),h,_,k,v,m])}const w=t(o,[["render",b],["__file","魔术方法.html.vue"]]);export{w as default};
