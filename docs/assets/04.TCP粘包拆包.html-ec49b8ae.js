import{_ as d,W as r,X as t,Y as e,Z as a,$ as i,a2 as o,C as c}from"./framework-7d1f27fd.js";const n={},s=o(`<h1 id="tcp-粘包拆包" tabindex="-1"><a class="header-anchor" href="#tcp-粘包拆包" aria-hidden="true">#</a> TCP 粘包拆包</h1><p>IP 协议解决了数据包（Packet）的<code>路由</code>和<code>寻址</code>，上层的 TCP 协议不再关注路由和寻址，那么 TCP 协议解决的是传输的<code>可靠性</code>和<code>顺序</code>问题，上层不需要关心数据能否传输到目标进程，只要写入 TCP 协议的缓冲区的数据，协议栈几乎都能保证数据的送达。</p><h2 id="粘包问题" tabindex="-1"><a class="header-anchor" href="#粘包问题" aria-hidden="true">#</a> 粘包问题</h2><p>当应用层协议使用 TCP 协议传输数据时，TCP 协议可能会将应用层发送的数据分成多个包依次发送，而数据的接收方收到的数据段可能有多个『应用层数据包』组成，所以当应用层从 TCP 缓冲区中读取数据时，发现数据包是粘连的，就需要对收到的数据进行拆分(分包)。</p><p>在 TCP 这种字节流协议上做<code>应用层分包</code>是网络编程的基本需求。分包指的是在发生一个消息(message)或一帧(frame)数据时，通过一定的处理，让接收方能从字节流中识别并截取(还原)出一个个消息。因此，<code>“粘包问题”是个伪命题</code></p><p><code>粘包并不是 TCP 协议造成的</code>，它的出现是因为应用层协议设计者对 TCP 协议的错误理解，忽略了 TCP 协议的定义并且缺乏设计应用层协议的经验。本文将从 TCP 协议以及应用层协议出发，分析我们经常提到的 TCP 协议中的粘包是如何发生的：</p><ul><li>TCP 协议是面向字节流的协议，它可能会组合或者拆分应用层协议的数据；</li><li>应用层协议的没有定义消息的边界导致数据的接收方无法拼接数据；</li></ul><p>很多人可能会认为粘包是一个比较低级的甚至不值得讨论的问题，但是在作者看来这个问题还是很有趣的，不是所有人都系统性地学过基于 TCP 的应用层协议设计，也不是所有人对 TCP 协议都有那么深入的理解，相信很多人学习编程的过程都是自顶向下的，所以作者认为这是一个值得回答的问题，我们应该传递正确的知识，而不是负面的和居高临下的情绪。</p><h2 id="短连接分包" tabindex="-1"><a class="header-anchor" href="#短连接分包" aria-hidden="true">#</a> 短连接分包</h2><p>对于短连接的 TCP 服务，分包不是一个问题，只要发送方主动关闭连接，就表示一个消息发送完毕，接收方 read() 返回0，从而知道消息的结尾</p><h2 id="tcp-发送机制" tabindex="-1"><a class="header-anchor" href="#tcp-发送机制" aria-hidden="true">#</a> TCP 发送机制</h2><p>为了提高 TCP 的传输效率，TCP 有一套自己的发送机制</p><ul><li>TCP 维持一个变量，它等于<code>最大报文段长度 MSS</code>。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去</li><li>由发送方的应用进程指明要求发送报文段，即 TCP 支持的<code>推送(push)</code>操作</li><li>发送方的一个计时器期限到了，这时把当前已有的缓存数据装入报文段(但长度不能超过 MSS)发送出去</li></ul><h2 id="长连接分包" tabindex="-1"><a class="header-anchor" href="#长连接分包" aria-hidden="true">#</a> 长连接分包</h2><p>既然 TCP 协议是基于字节流的，这其实就意味着应用层协议要自己划分消息的边界。在应用层协议中，最常见的两种解决方案就是基于<code>长度</code>或者<code>基于终结符（Delimiter）</code>。</p><p>对于长连接的 TCP 服务，分包有四种方法</p><ul><li>消息长度固定</li><li>使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\\r\\n”为字段的分隔符</li><li>在每条消息的头部加一个长度字段，这恐怕是最常见的做法 -- HTTP 协议的消息边界就是基于长度实现的</li><li>利用消息本身的格式来分包，例如 XML 格式的消息中 <code>&lt;root&gt;</code>...<code>&lt;/root&gt;</code> 的配对，或者 JSON 格式中的 { ... } 的配对。解析这种消息格式通常会用到状态机(state machine)</li></ul><h2 id="复杂的分包" tabindex="-1"><a class="header-anchor" href="#复杂的分包" aria-hidden="true">#</a> 复杂的分包</h2><p>假如消息格式非常简单，“消息”本身是一个字符串，每条消息有一个4字节的头部，以网络序存放字符串的长度。消息直接没有间隙，字符串也不要求以 &#39;\\0&#39; 结尾</p><p>发送两条消息“hello”和“smartboy”，打包后的字节流共有21字节</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0x00, 0x00, 0x00, 0x05, &#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;,
0x00, 0x00, 0x00, 0x08, &#39;s&#39;, &#39;m&#39;, &#39;a&#39;, &#39;r&#39;, &#39;t&#39;, &#39;b&#39;, &#39;o&#39;, &#39;y&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>假设数据最终都全部到达，数据解析逻辑至少能正确处理以下各种数据到达的次序</p><ul><li>一个字节一个字节到达</li><li>数据分两次到达，第一次收到2个字节，不足消息的长度字段</li><li>数据分两次到达，第一次收到4个字节，刚好够长度字段，但是没有 body</li><li>数据分两次到达，第一次收到8个字节，长度完整，但 body 不完整</li><li>数据分两次到达，第一次收到9个字节，长度完整，但 body 也完整</li><li>数据分两次到达，第一次收到10个字节，第一条消息的长度完整、body 也完整，第二条消息长度不完整</li><li>请自行移动和增加分割点，一共有超过 100 万种可能(2<sup>21-1</sup>)</li><li>数据一次就全部到达</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h3><p>TCP 协议粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身不包含消息、数据包等概念，所有数据的传输都是流式的，需要应用层协议自己设计消息的边界，即消息帧（Message Framing），我们重新回顾一下粘包问题出现的核心原因：</p><ul><li>TCP 协议是基于字节流的传输层协议，其中不存在消息和数据包的概念；</li><li>应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连；</li></ul>`,26),h={href:"https://blog.maplemark.cn/2019/04/tcp%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85.html",target:"_blank",rel:"noopener noreferrer"},p={href:"https://draveness.me/whys-the-design-tcp-message-frame/",target:"_blank",rel:"noopener noreferrer"};function T(u,C){const l=c("ExternalLinkIcon");return r(),t("div",null,[s,e("p",null,[e("strong",null,[a("《TCP粘包拆包》 原文链接："),e("a",h,[a("https://blog.maplemark.cn/2019/04/tcp粘包拆包.html"),i(l)])])]),e("p",null,[e("a",p,[a("https://draveness.me/whys-the-design-tcp-message-frame/"),i(l)])])])}const m=d(n,[["render",T],["__file","04.TCP粘包拆包.html.vue"]]);export{m as default};
