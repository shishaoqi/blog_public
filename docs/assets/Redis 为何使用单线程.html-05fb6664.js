const e=JSON.parse('{"key":"v-c255b452","path":"/interview/Redis/Redis%20%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B.html","title":"为什么Redis单线程还这么快？","lang":"zh-CN","frontmatter":{"description":"为什么Redis单线程还这么快？ 使用单线程模型能带来更好的可维护性，方便开发和调试； 使用单线程模型也能并发的处理客户端的请求； 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。 严格来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的。这一点我们一定要清楚了解到，不要单纯地认为Redis Server是单线程的！","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/article/docs/interview/Redis/Redis%20%E4%B8%BA%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"博客"}],["meta",{"property":"og:title","content":"为什么Redis单线程还这么快？"}],["meta",{"property":"og:description","content":"为什么Redis单线程还这么快？ 使用单线程模型能带来更好的可维护性，方便开发和调试； 使用单线程模型也能并发的处理客户端的请求； 官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。 严格来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的。这一点我们一定要清楚了解到，不要单纯地认为Redis Server是单线程的！"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"为什么Redis单线程还这么快？\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":0.96,"words":287},"filePathRelative":"interview/Redis/Redis 为何使用单线程.md","excerpt":"<h1> 为什么Redis单线程还这么快？</h1>\\n<ol>\\n<li>使用单线程模型能带来更好的可维护性，方便开发和调试；</li>\\n<li>使用单线程模型也能并发的处理客户端的请求；</li>\\n</ol>\\n<p>官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>\\n<p>严格来说，Redis Server是多线程的，只是它的请求处理整个流程是单线程处理的。这一点我们一定要清楚了解到，不要单纯地认为Redis Server是单线程的！</p>","autoDesc":true}');export{e as data};
