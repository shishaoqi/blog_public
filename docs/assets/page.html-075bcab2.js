import{_ as i,W as d,X as r,Y as e,Z as a,$ as n,a0 as s,a2 as l,C as c}from"./framework-7d1f27fd.js";const o={},p={href:"http://doc.cat-v.org/plan_9/4th_edition/papers/comp",target:"_blank",rel:"noopener noreferrer"},u=e("h3",{id:"机器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#机器","aria-hidden":"true"},"#"),a(" 机器")],-1),v=e("p",null,"对于 MIPS、SPARC、Intel 386、AMD64、Power PC 和 ARM 都有一个对应的汇编器。68020 汇编器 ，2a（不再分发）是最古老的，并且在许多方面都是原型。 汇编器实际上只是单个程序的变体：它们共享许多属性（例如：指令操作是从左到右的赋值顺序）和宏指令的合成（例如：隐藏加载的独特性与机器的存储结构的MOVE指令）。 为了说明能具体，本手册的第一部分专门针对 68020。最后是对其他汇编器之间差异的描述。",-1),h={class:"hint-container tip"},m=e("p",{class:"hint-container-title"},"提示",-1),x={href:"https://theme-hope.vuejs.press/zh/guide/layout/breadcrumb.html",target:"_blank",rel:"noopener noreferrer"},g=l(`<h3 id="寄存器" tabindex="-1"><a class="header-anchor" href="#寄存器" aria-hidden="true">#</a> 寄存器</h3><p>汇编程序中的所有预定义符号都是大写的。数据寄存器是R0到R7; 地址寄存器为A0到A7; 浮点寄存器从F0到F7。</p><p>A6中的指针被C编译器用来指向数据，使短地址更经常地被使用。A6的值是个常量，必须在C程序初始化时设置为外部定义的符号a6base的地址。以下硬件寄存器在汇编程序中定义;对于 CAAR、CACR、CCR、DFC、ISP、MSP、SFC、SR、USP和VBR 的含意在68020手册已经给出说明。</p><p>汇编程序还定义了几个伪寄存器 -- 操作堆栈的：FP、SP和TOS。FP 是帧指针，因此0(FP)是第一个参数，4(FP)是第二个参数，依此类推。SP 是本地栈指针，其中保存自动变量(SP是只在68020上的伪寄存器);0(SP)是第一个自动变量，同FP一样以此类推。最后，TOS 是栈顶寄存器，用于将参数推入程序、保存临时值等等。</p><p>编译器与加载器追踪这些伪寄存器，因为以上声明所以无视被推入硬件寄存的数据及 A7 所指向的是正确的。A7 指向硬件栈指针，但小心 A7 的混合用法和上面栈相关的伪寄存器，它们会制造问题。同时要注意，PEA 指令是由改变 SP 的加载器所观察，因此在所有返回前会插入一个响应 pop。编译器接受一个标签相似的名称附加到 FP和SP 上的用法，例如 p+0(FP),为了起到说明作用 p 通常是第一个参数。名称在符号表上，但对程序的结果没有意义。</p><h3 id="数据引用" tabindex="-1"><a class="header-anchor" href="#数据引用" aria-hidden="true">#</a> 数据引用</h3><p>所有外部引用都必须被关联到一些伪寄存器，不是 PC(the virtual program counter) 就是 SB(the ‘‘static base’’ register)。PC 计数指令，不是数据字节。举例：要分支到接下来的第二个指令，也就是说，要跳过一项本可以写的指令</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>BRA 2(PC)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用标签也是可以的，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  BRA return
  NOP
return:
  RTS
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当使用标签时，不存在 PC 注释。 伪寄存器 SB 指向程序地址空间的开始位置。因此，全局变量和程序的引用被写为对于 SB 的偏移，如下：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>MOVL  $array(SB), TOS
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面指令，把全局数组的地址压入到栈上，或：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>MOVL  array+4(SB), TOS
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上面指令，把数组的第二变量（4字节大小）压入栈。注意偏移的运用；地址模式的完整列表如下。同样，子例程呼叫必须使用SB：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>BSR exit(SB)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>文件静态变量具有语法</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>local&lt;&gt;+4(SB)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>&lt;&gt;将在加载时由一个唯一的整数填充</p><p>当一个程序运行时，在访问任何全局数据前，它必须执行</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>MOVL  $a6base(SB), A6
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在无法以单个指令中加载寄存器的MIP和SPARC等机器上，常数通过 SB 寄存器加载。加载程序识别初始化静态基础寄存器并专门处理它的代码。要小心，但，当 SB 寄存器未设置时(例如在中断的例程中)，在此类机器上不要加载大型常数</p><h3 id="表达式" tabindex="-1"><a class="header-anchor" href="#表达式" aria-hidden="true">#</a> 表达式</h3>`,23);function b(S,_){const t=c("ExternalLinkIcon");return d(),r("div",null,[e("p",null,[e("a",p,[a("原文"),n(t)]),a(" 这篇文章会在原文翻译基础上做补充，很大可能与原文有着很大区别，若想原汁原味请查看原文。")]),s(" more "),u,v,e("div",h,[m,e("p",null,[a("罗布·派克（Rob Pike）的文档"),e("a",x,[a("“如何使用计划9 C编译器”"),n(t)]),a("是本手册的先决条件。")])]),g])}const C=i(o,[["render",b],["__file","page.html.vue"]]);export{C as default};
